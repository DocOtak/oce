/* vim: set expandtab shiftwidth=2 softtabstop=2 tw=70: */

//#define DEBUG

#include <Rcpp.h>
using namespace Rcpp;

// Cross-reference work:
// 1. update ../src/registerDynamicSymbol.c with an item for this
// 2. main code should use the autogenerated wrapper in ../R/RcppExports.R
//
// [[Rcpp::export]]
NumericVector do_topo_interpolate(NumericVector lon, NumericVector lat, NumericVector zlon, NumericVector zlat, NumericMatrix z)
{
  int nlat = lat.size();
  if (nlat != lon.size())
    ::Rf_error("lengths of latitude (%d) and longitude (%d) must match", nlat, lon.size());
  NumericVector ans(nlat);
  int nzlat = z.ncol(), nzlon = z.nrow();
  // It is safe to assume a uniform grid, so next two calculations apply throughout
  double dzlat = zlat[1] - zlat[0];
  double dzlon = zlon[1] - zlon[0];
#ifdef DEBUG
  Rprintf("zlon=%f %f %f ...; dzlon=%f nzlon=%d\n", zlon[0], zlon[1], zlon[2], dzlon, nzlon);
  Rprintf("zlat=%f %f %f ...; dzlat=%f nzlat=%d\n", zlat[0], zlat[1], zlat[2], dzlat, nzlat);
#endif
  for (int i = 0; i < nlat; i++) {
    int izlat = (int)floor((lat[i] - zlat[0]) / dzlat);
    int izlon = (int)floor((lon[i] - zlon[0]) / dzlon);
#ifdef DEBUG
    Rprintf("%.0fE %.0fN izlon=%d izlat=%d nzlon=%d nzlat=%d zlat[izlat]=%.0f zlon[izlon]=%.0f\n",
        lon[i], lat[i], izlon, izlat, nzlon, nzlat, zlat[izlat], zlon[izlon]);
#endif
    if (izlat < 0 || izlat > (nzlat - 1) || izlon < 0 || izlon > (nzlon - 1)) {
#ifdef DEBUG
      Rprintf("  setting NA; izlon=%d izlat=%d nzlon=%d nzlat=%d\n", izlon, izlat, nzlon, nzlat);
#endif
      ans[i] = NA_REAL;
    } else {
      // http://en.wikipedia.org/wiki/Bilinear_interpolation
      double y = (lat[i] - zlat[izlat]) / dzlat;
      double x = (lon[i] - zlon[izlon]) / dzlon;
      double zll = z(izlon  , izlat  ); // or reverse?
      double zlr = z(izlon  , izlat+1);
      double zur = z(izlon+1, izlat+1);
      double zul = z(izlon+1, izlat  );
#ifdef DEBUG
      Rprintf(" x=%.0f y=%.0f zll=%.0f zlr=%.0f zur=%.0f zul=%.0f\n", x,y,zll,zlr,zur,zul);
#endif
      ans[i] = zll * (1.0 - x) * (1.0 - y) +
        zlr * x * (1.0 - y) +
        zul * (1.0 - x) * y +
        zur * x * y;
    }
  }
  return(ans);
}
