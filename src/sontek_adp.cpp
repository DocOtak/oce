/* vim: set expandtab shiftwidth=2 softtabstop=2 tw=70: */

#define DEBUG

#include <Rcpp.h>
using namespace Rcpp;

// The manuals say 0xA596, but below, we create the full 2-byte
// checksum with bit-shifting, to avoid having to consider endianness.
#define CHECK_SUM_OFFSET_BYTE1 0xA5
#define CHECK_SUM_OFFSET_BYTE21 0x96

// Limit for the extent of debugging output in each stage of the
// processing.
#define MESSAGE_LIMIT 20

// Cross-reference work:
// 1. update ../src/registerDynamicSymbol.c with an item for this
// 2. main code should use the autogenerated wrapper in ../R/RcppExports.R
//
// [[Rcpp::export]]
IntegerVector do_ldc_sontek_adp(RawVector buf,
    IntegerVector have_ctd,
    IntegerVector have_gps,
    IntegerVector have_bottom_track,
    IntegerVector type, // 0 for adp; 1 for argonaut_adp; 2 for pcadp
    IntegerVector max)
{
  unsigned int imessage = 0, max_messages = MESSAGE_LIMIT;
  unsigned int is_adp = type[0] == 0;
  unsigned int is_argonaut_adp = type[0] == 1;
  unsigned int is_pcadp = type[0] == 2;
#ifdef DEBUG
  Rprintf("have_ctd=%d, have_bottom_track=%d, have_gps=%d, type=%d, max=%d\n",
      have_ctd[0], have_bottom_track[0], have_gps[0], type[0], max[0]);
  Rprintf("is_adp=%d, is_argonaut_adp=%d, is_pcadp=%d\n", is_adp, is_argonaut_adp, is_pcadp);
#endif

  // ldc = locate data chunk; _sontek_adp = for a SonTek ADV.
  // Arguments:
  //   buf = buffer with data
  //   have_ctd = 1 if have CTD data (must be 0, for this version)
  //   have_gps = 1 if have GPS data (must be 0, for this version)
  //   have_bottom_track = 1 if have bottom-track data (must be 0, for this version)
  //   type = 0 for adp, 1 argonaut_adp, 2 for pcadp
  //   max = number of profiles to get (set to <0 to get all)
  //
  // Method for type=0 (adp):
  //   The code checks for 3 bytes as follows, and does a checksum on
  //   results.  It has to determine ncell and nbeam first.
  //     BYTE   Contents
  //       1    0xA5 (flag 1)
  //       2    0x10 (flag 2)
  //       3    0x50 (decimal 80, number of bytes in header)
  // Method for type=1 (argonaut_adp):
  //   The code checks 2 bytes to see if they match 0x80 and 0x26,
  //   which is used for "long" format entries, or if they match
  //   0x81 and 0x16 for "short" format. See print pages 89 and 90
  //   of reference 2.
  //
  // Method for type=2 (pcadp):
  //   The code works as for type=0, but with some modifications
  //   to account for differences in format.
  //
  // REFERENCES
  //
  // 1. SonTek/YSI Incorporated. "ADP (Acoustic Doppler Profiler)
  // Operation Manual Firmware Version 7.1." SonTek/YSI, March 2001.
  //
  // 2. SonTek/YSI Incorporated. "Argonaut Acoustic Doppler Current Meter
  // Operation Manual Firmware Version 7.9." SonTek/YSI, May 1, 2001.
  // https://eng.ucmerced.edu/snsjho/files/San_Joaquin/Sensors_and_Loggers/SonTek/SonTek_Argonaut/ArgonautXR.pdf.
  //
  // 3. hydratools20apr06/adp2cdf.m line 1360 re PCADP's extra header.
  unsigned char adpByte1 = 0xA5;
  unsigned char adpByte2 = 0x10;
  unsigned char adpByte3 = 0x50; // decimal 80 (number of bytes in header)
  unsigned char argonautLongByte1 = 0xB0;
  //unsigned char argonautLongByte2 = 0x26; // ADP decimal 38 (number of bytes in header)
  unsigned char argonautLongByte2 = 0xa1; // decimal 161 (seen in a particular file)
  unsigned char argonautShortByte1 = 0xB1;
  unsigned char argonautShortByte2 = 0x16; // decimal 22 (number of bytes in header)
  if (have_ctd[0] != 0)
    ::Rf_error("cannot read SonTek ADP files with CTD data");
  if (have_bottom_track[0] != 0)
    ::Rf_error("cannot read SonTek ADP files with bottom-track data");
  if (have_gps[0] != 0)
    ::Rf_error("cannot read SonTek ADP files with GPS data");
  int nbuf = buf.size();
#ifdef DEBUG
  Rprintf("nbuf=%d\n", nbuf);
#endif
  /* Count matches, so we can allocate the right length */
  unsigned int matches = 0;
  unsigned short int check_sum_start = ((unsigned short)0xa5<<8)  | ((unsigned short)0x96); /* manual p96 says 0xA596; assume little-endian */
  if (max[0] < 0)
    max[0] = 0;
  /* scan first profile to determine ncell and nbeam */
  int first_look = 2000;
  if (first_look > nbuf)
    ::Rf_error("cannot read Sontek ADP from a buffer with fewer than 100 bytes");
  int i;
  int ncell = -1, nbeam = -1;
  imessage = 0;
  max_messages = MESSAGE_LIMIT;
  for (i = 0; i < first_look - 3; i++) { /* note that we don't look to the very end */
    //Rprintf(" %d: %x %x %x (%x %x %x)\n", i, buf[i], buf[i+1], buf[i+2], adpByte1, adpByte2, adpByte3);
    if ((is_adp || is_pcadp) && buf[i] == adpByte1 && buf[i+1] == adpByte2 && buf[i+2] == adpByte3) {
      nbeam = (int)buf[i + 26];
      ncell = ((unsigned short)buf[i+30]) | ((unsigned short)buf[i+31] << 8);
#ifdef DEBUG
      if (imessage++ < max_messages)
        Rprintf("tentative first-profile at buf[%d], yielding nbeam=%d and ncell=%d (message %d/%d)\n",
            i, nbeam, ncell, imessage, max_messages);
#endif
      if (nbeam < 2 || nbeam > 3)
        ::Rf_error("number of beams must be 2 or 3, but it is %d", nbeam);
      if (ncell < 1)
        ::Rf_error("number of cells cannot be less than 1, but it is %d", ncell);
      break;
    } else if (is_argonaut_adp && buf[i] == argonautShortByte1 && buf[i+1] == argonautShortByte2) {
#ifdef DEBUG
      if (imessage++ < max_messages)
        Rprintf("tentative first-profile argonaut_adp short record at i=%d (message %d/%d)\n",
            i, imessage, max_messages);
#endif
    } else if (is_argonaut_adp && buf[i] == argonautLongByte1 && buf[i+1] == argonautLongByte2) {
#ifdef DEBUG
      if (imessage++ < max_messages)
        Rprintf("tentative first-profile argonaut_adp long record at i=%d (message %d/%d)\n",
            i, imessage, max_messages);
#endif
    }
  }
  imessage = 0;
  max_messages = MESSAGE_LIMIT;
  if ((is_adp || is_pcadp) && (nbeam < 0 || ncell < 0))
    ::Rf_error("cannot determine #beams or #cells, based on first 1000 bytes in buffer");
  // The next line envisions more data streams, e.g. ctd.
  int chunk_length = 80 + (have_ctd[0]?16:0) + (have_gps[0]?40:0) + (have_bottom_track[0]?18:0) + 4 * ncell * nbeam;
  // Next 2 lines acount for extra header in each PCADP profile; see ref 2.
  int max_beams = 4;
  int pcadp_extra_header_length = 2*(8+max_beams) + 2*max_beams + max_beams;
  if (is_pcadp)
    chunk_length += pcadp_extra_header_length;
  int bad = 0, maxbad = 100;
#ifdef DEBUG
  Rprintf("is_pcadp=%d pcadp_extra_header_length=%d max_beams=%d\n", is_pcadp, pcadp_extra_header_length, max_beams);
  if (is_adp || is_pcadp)
    Rprintf("chunk_length: %d\n", chunk_length);
#endif
  for (int i = 0; i < nbuf - 3 - chunk_length; i++) { // FIXME is 3 right, or needed?
    if ((is_adp || is_pcadp) && buf[i] == adpByte1 && buf[i+1] == adpByte2 && buf[i+2] == adpByte3) {
      unsigned short int check_sum = check_sum_start; // RHS is fixed
      unsigned short int desired_check_sum = ((unsigned short)buf[i+chunk_length]) | ((unsigned short)buf[i+chunk_length+1] << 8);
      for (int c = 0; c < chunk_length; c++)
        check_sum += (unsigned short int)buf[i + c];
      if (check_sum == desired_check_sum) {
        matches++;
#ifdef DEBUG
        if (imessage++ < max_messages)
          Rprintf("OK  at buf[%d]: check_sum=%d (should be %d); check_sum_start=%d (message %d/%d)\n",
              i, check_sum, desired_check_sum, check_sum_start, imessage, max_messages);
#endif
        if (max[0] != 0 && matches >= (unsigned int)max[0])
          break;
      } else {
#ifdef DEBUG
        if (imessage++ < max_messages)
          Rprintf("BAD at buf[%d]: check_sum=%d (should be %d); check_sum_start=%d (message %d/%d)\n",
              i, check_sum, desired_check_sum, check_sum_start, imessage, max_messages);
#endif
        if (bad++ > maxbad)
          ::Rf_error("bad=%d exceeds maxbad=%d\n", bad, maxbad);
      }
    } else if (is_argonaut_adp && buf[i] == argonautShortByte1 && buf[i+1] == argonautShortByte2) {
#ifdef DEBUG
      if (imessage++ < max_messages)
        ::Rprintf("adp short record at i=%d FIXME: CODE checksum calc (message %d/%d)\n",
            i, imessage, max_messages);
#endif
    } else if (is_argonaut_adp && buf[i] == argonautLongByte1 && buf[i+1] == argonautLongByte2) {
      chunk_length = 161; // FIXME: this might work in a test file (just exploring with this code)
      unsigned short int check_sum = check_sum_start; // RHS is fixed
      //unsigned short int desired_check_sum = (unsigned short int)buf[i+chunk_length-1];
      unsigned char desired_check_sum = (unsigned char)buf[i+chunk_length-1];
      for (int c = 0; c < chunk_length; c++) {
        //check_sum += (unsigned short int)buf[i + c];
        check_sum += (unsigned char)buf[i + c];
        if (bad < maxbad)
          Rprintf("    i=%d c=%d buf[%d]=0x%02x check_sum=0x%04x 0x%02x\n",
              i, c, i+c, buf[i+c], (unsigned short int)check_sum, (unsigned char)check_sum);
      }
      if ((unsigned char)check_sum == desired_check_sum) {
        matches++;
#ifdef DEBUG
        if (imessage++ < max_messages)
          Rprintf("OK  argonaut-long record at buf[%d]: check_sum=0x%02x (should be 0x%02x 0x%02x 0x%02x 0x%02x 0x%02x 0x%02x 0x%02x) (message %d/%d)\n",
              i, (unsigned char)check_sum, //desired_check_sum,
              (unsigned short int)buf[i+chunk_length-3],
              (unsigned short int)buf[i+chunk_length-2],
              (unsigned short int)buf[i+chunk_length-1],
              (unsigned short int)buf[i+chunk_length],
              (unsigned short int)buf[i+chunk_length+1],
              (unsigned short int)buf[i+chunk_length+2],
              (unsigned short int)buf[i+chunk_length+3],
              imessage, max_messages);
#endif
        if (max[0] != 0 && matches >= (unsigned int)max[0])
          break;
      } else {
#ifdef DEBUG
        if (imessage++ < max_messages)
          Rprintf("BAD argonaut-long record at buf[%d]: check_sum=0x%02x (should be 0x%02x 0x%02x ?0x%02x 0x%02x 0x%02x 0x%02x 0x%02x) (message %d/%d)\n",
              i, (unsigned char)check_sum, //desired_check_sum,
              (unsigned short int)buf[i+chunk_length-3],
              (unsigned short int)buf[i+chunk_length-2],
              (unsigned short int)buf[i+chunk_length-1],
              (unsigned short int)buf[i+chunk_length],
              (unsigned short int)buf[i+chunk_length+1],
              (unsigned short int)buf[i+chunk_length+2],
              (unsigned short int)buf[i+chunk_length+3],
              imessage, max_messages);
#endif
        if (bad++ > maxbad)
          ::Rf_error("bad=%d exceeds maxbad=%d\n", bad, maxbad);
      }
    } else if (is_argonaut_adp && buf[i] == argonautShortByte1 && buf[i+1] == argonautShortByte2) {
#ifdef DEBUG
        if (imessage++ < max_messages)
          Rprintf("Skipping (not checksumming) possible argonaut-short record at buf[%d] (message %d/%d)\n",
              i, imessage, max_messages);
#endif
    }
  }
  /* allocate space, then run through whole buffer again, noting the matches */
  imessage = 0;
  max_messages = MESSAGE_LIMIT;
  unsigned int nres = matches;
  IntegerVector res(nres>0?nres:1, 1);
  if (nres > 0) {
#ifdef DEBUG
    ::Rprintf("getting space for %d matches\n", nres);
#endif
    unsigned int ires = 0;
    for (int i=0; i<(nbuf-3-chunk_length); i++) { // FIXME is 3 right, or needed?
      if ((is_adp || is_pcadp) && buf[i] == adpByte1 && buf[i+1] == adpByte2 && buf[i+2] == adpByte3) {
        unsigned short int check_sum = check_sum_start; // RHS is fixed
        unsigned short int desired_check_sum = ((unsigned short)buf[i+chunk_length]) | ((unsigned short)buf[i+chunk_length+1] << 8);
        for (int c = 0; c < chunk_length; c++)
          check_sum += (unsigned short int)buf[i + c];
        if (check_sum == desired_check_sum)
          res[ires++] = i + 1; /* the +1 is to get R pointers */
        if (ires > nres)        /* FIXME: or +1? */
          break;
      } else if (is_argonaut_adp && buf[i] == argonautShortByte1 && buf[i+1] == argonautShortByte2) {
#ifdef DEBUG
        if (imessage++ < max_messages)
          ::Rprintf("adp short record at i=%d -- getting space (message %d/%d)\n",
              i, imessage, max_messages);
#endif
      } else if (is_argonaut_adp && buf[i] == argonautLongByte1 && buf[i+1] == argonautLongByte2) {
#ifdef DEBUG
        if (imessage++ < max_messages)
          ::Rprintf("adp long record at i=%d -- getting space (message %d/%d)\n",
              i, imessage, max_messages);
#endif
      }
    }
    return(res);
  } else {
    res[0] = NA_INTEGER;
#ifdef DEBUG
    ::Rprintf("no data chunks identified\n");
#endif
  }
  return(res);
}
