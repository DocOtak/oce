% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/geod.R
\name{geodXy}
\alias{geodXy}
\title{Convert From Geographical to Geodesic Coordinates}
\usage{
geodXy(longitude, latitude, longitudeRef = 0, latitudeRef = 0, rotate = 0,
  debug = getOption("oceDebug"))
}
\arguments{
\item{longitude, latitude}{vector of longitude and latitude}

\item{longitudeRef, latitudeRef}{numeric reference location. Poor results
will be returned if these values are not close to the locations described
by \code{longitude} and \code{latitude}. A sensible approach might be
to set \code{longitudeRef} to \code{longitude[1]}, etc.}

\item{rotate}{numeric, counterclockwise angle, in degrees, by which to
rotate the (\code{x}, \code{y}) coordinates about the reference point.  This
is useful in rotating the coordinate system to align with a coastline, a
mean current, etc.}

\item{debug}{an integer specifying whether debugging information is
to be printed during the processing. This is a general parameter that
is used by many \code{oce} functions. Generally, setting \code{debug=0}
turns off the printing, while higher values suggest that more information
be printed. If one function calls another, it usually reduces the value of
\code{debug} first, so that a user can often obtain deeper debugging
by specifying higher \code{debug} values.}
}
\value{
Data frame of \code{x} and \code{y}, geodesic distance components,
measured in metres. See \dQuote{Details} for the definitions.
}
\description{
The method employs geodesic calculations of the distances along geodesic
curves, i.e. akin to great-circle curves that go along the surface of the
ellipsoidal earth. See \dQuote{Caution}.
}
\details{
The calculation is as follows.
Consider the \code{i}-th point in the \code{longitude} and \code{latitude}
vectors.  To calculate \code{x[i]}, \code{\link{geodDist}} is
used is to find the distance \emph{along a
geodesic curve} connecting (\code{longitude[i]}, \code{latitude[i]}) with
(\code{longitudeRef}, \code{latitude[i]}). The resultant distance
is multiplied by -1 if \code{longitude[i]-longitudeRef} is negative,
and the result is assigned to \code{x[i]}. 
A similar procedure is used for \code{y[i]}.
}
\section{Caution}{
 This scheme is without known precedent in the literature, and
users would be better off using \code{\link{lonlat2utm}} instead.
}

\section{Change notifications}{
 Until 2015-11-02, the names of the arguments
were \code{lon}, \code{lat}, \code{lon.ref} and \code{lat.ref}; these were
changed to be more in keeping with names in the rest of oce. Until
2017-04-05, defaults of 0 and 0 were used for the reference location, but
this is very seldom useful, and can yield bad results if the goal is to
set up an x-y system for moorings or CTD locations.
}

\examples{
library(oce)
data(section)
lon <- section[["longitude", "byStation"]]
lat<- section[["latitude", "byStation"]]
lon <- lon
lat <- lat
lonR <- lon[1]
latR <- lat[1]
## 1. ellipse
km <- 1e3 # nicer for graphs
xy <- geodXy(lon, lat, lonR, latR) / km
## 2. sphere, with scale tailored to mean local latitude
kmperdeg <- geodDist(0, mean(lat)-0.5, 0, mean(lat)+0.5) # mid-latitude estimate
X <- (lon - lonR) * kmperdeg * cos(lat * pi / 180)
Y <- (lat - latR) * kmperdeg
XY <- list(x=X, y=Y)
# plot, with labels for sphere-ellipse deviations
par(mfrow=c(2,1), mar=c(3, 3, 1, 1), mgp=c(2, 0.7, 0))
plot(lon, lat, asp=1/cos(median(lat*pi/180)))
plot(xy$x, xy$y, asp=1, xlab="x [km]", ylab="y [km]")
rms<- function(x) sqrt(mean(x^2))
mtext(sprintf("RMS dev.: x \%.2f km, y \%.2f km",
              rms(xy$x-XY$x), rms(xy$y-XY$y)), side=3, line=-1)
mtext(sprintf("RMS dev / span: x \%.2g, y \%.2g",
              rms(xy$x-XY$x)/diff(range(xy$x)),
              rms(xy$y-XY$y)/diff(range(xy$y))),
      side=3, line=-2)
}
\seealso{
\code{\link{geodDist}}

Other functions relating to geodesy: \code{\link{geodDist}},
  \code{\link{geodGc}}, \code{\link{geodXyInverse}}
}
\author{
Dan Kelley
}
